// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package nats_test

import (
	natsgo "github.com/nats-io/nats.go"
	brokernats "github.com/x4b1/messenger/broker/nats"
	"sync"
)

// Ensure, that ConnMock does implement brokernats.Conn.
// If this is not the case, regenerate this file with moq.
var _ brokernats.Conn = &ConnMock{}

// ConnMock is a mock implementation of brokernats.Conn.
//
//	func TestSomethingThatUsesConn(t *testing.T) {
//
//		// make and configure a mocked brokernats.Conn
//		mockedConn := &ConnMock{
//			PublishMsgFunc: func(m *natsgo.Msg) error {
//				panic("mock out the PublishMsg method")
//			},
//			SubscribeFunc: func(subj string, cb natsgo.MsgHandler) (*natsgo.Subscription, error) {
//				panic("mock out the Subscribe method")
//			},
//		}
//
//		// use mockedConn in code that requires brokernats.Conn
//		// and then make assertions.
//
//	}
type ConnMock struct {
	// PublishMsgFunc mocks the PublishMsg method.
	PublishMsgFunc func(m *natsgo.Msg) error

	// SubscribeFunc mocks the Subscribe method.
	SubscribeFunc func(subj string, cb natsgo.MsgHandler) (*natsgo.Subscription, error)

	// calls tracks calls to the methods.
	calls struct {
		// PublishMsg holds details about calls to the PublishMsg method.
		PublishMsg []struct {
			// M is the m argument value.
			M *natsgo.Msg
		}
		// Subscribe holds details about calls to the Subscribe method.
		Subscribe []struct {
			// Subj is the subj argument value.
			Subj string
			// Cb is the cb argument value.
			Cb natsgo.MsgHandler
		}
	}
	lockPublishMsg sync.RWMutex
	lockSubscribe  sync.RWMutex
}

// PublishMsg calls PublishMsgFunc.
func (mock *ConnMock) PublishMsg(m *natsgo.Msg) error {
	callInfo := struct {
		M *natsgo.Msg
	}{
		M: m,
	}
	mock.lockPublishMsg.Lock()
	mock.calls.PublishMsg = append(mock.calls.PublishMsg, callInfo)
	mock.lockPublishMsg.Unlock()
	if mock.PublishMsgFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PublishMsgFunc(m)
}

// PublishMsgCalls gets all the calls that were made to PublishMsg.
// Check the length with:
//
//	len(mockedConn.PublishMsgCalls())
func (mock *ConnMock) PublishMsgCalls() []struct {
	M *natsgo.Msg
} {
	var calls []struct {
		M *natsgo.Msg
	}
	mock.lockPublishMsg.RLock()
	calls = mock.calls.PublishMsg
	mock.lockPublishMsg.RUnlock()
	return calls
}

// Subscribe calls SubscribeFunc.
func (mock *ConnMock) Subscribe(subj string, cb natsgo.MsgHandler) (*natsgo.Subscription, error) {
	callInfo := struct {
		Subj string
		Cb   natsgo.MsgHandler
	}{
		Subj: subj,
		Cb:   cb,
	}
	mock.lockSubscribe.Lock()
	mock.calls.Subscribe = append(mock.calls.Subscribe, callInfo)
	mock.lockSubscribe.Unlock()
	if mock.SubscribeFunc == nil {
		var (
			subscriptionOut *natsgo.Subscription
			errOut          error
		)
		return subscriptionOut, errOut
	}
	return mock.SubscribeFunc(subj, cb)
}

// SubscribeCalls gets all the calls that were made to Subscribe.
// Check the length with:
//
//	len(mockedConn.SubscribeCalls())
func (mock *ConnMock) SubscribeCalls() []struct {
	Subj string
	Cb   natsgo.MsgHandler
} {
	var calls []struct {
		Subj string
		Cb   natsgo.MsgHandler
	}
	mock.lockSubscribe.RLock()
	calls = mock.calls.Subscribe
	mock.lockSubscribe.RUnlock()
	return calls
}
