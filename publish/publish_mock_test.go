// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package publish

import (
	"context"
	"github.com/xabi93/messenger/store"
	"sync"
)

// Ensure, that SourceMock does implement Source.
// If this is not the case, regenerate this file with moq.
var _ Source = &SourceMock{}

// SourceMock is a mock implementation of Source.
//
// 	func TestSomethingThatUsesSource(t *testing.T) {
//
// 		// make and configure a mocked Source
// 		mockedSource := &SourceMock{
// 			MessagesFunc: func(ctx context.Context, publisherName string, batch int) ([]*store.Message, error) {
// 				panic("mock out the Messages method")
// 			},
// 			SaveLastPublishedFunc: func(ctx context.Context, publisherName string, msg *store.Message) error {
// 				panic("mock out the SaveLastPublished method")
// 			},
// 		}
//
// 		// use mockedSource in code that requires Source
// 		// and then make assertions.
//
// 	}
type SourceMock struct {
	// MessagesFunc mocks the Messages method.
	MessagesFunc func(ctx context.Context, publisherName string, batch int) ([]*store.Message, error)

	// SaveLastPublishedFunc mocks the SaveLastPublished method.
	SaveLastPublishedFunc func(ctx context.Context, publisherName string, msg *store.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// Messages holds details about calls to the Messages method.
		Messages []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublisherName is the publisherName argument value.
			PublisherName string
			// Batch is the batch argument value.
			Batch int
		}
		// SaveLastPublished holds details about calls to the SaveLastPublished method.
		SaveLastPublished []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublisherName is the publisherName argument value.
			PublisherName string
			// Msg is the msg argument value.
			Msg *store.Message
		}
	}
	lockMessages          sync.RWMutex
	lockSaveLastPublished sync.RWMutex
}

// Messages calls MessagesFunc.
func (mock *SourceMock) Messages(ctx context.Context, publisherName string, batch int) ([]*store.Message, error) {
	callInfo := struct {
		Ctx           context.Context
		PublisherName string
		Batch         int
	}{
		Ctx:           ctx,
		PublisherName: publisherName,
		Batch:         batch,
	}
	mock.lockMessages.Lock()
	mock.calls.Messages = append(mock.calls.Messages, callInfo)
	mock.lockMessages.Unlock()
	if mock.MessagesFunc == nil {
		var (
			messagesOut []*store.Message
			errOut      error
		)
		return messagesOut, errOut
	}
	return mock.MessagesFunc(ctx, publisherName, batch)
}

// MessagesCalls gets all the calls that were made to Messages.
// Check the length with:
//     len(mockedSource.MessagesCalls())
func (mock *SourceMock) MessagesCalls() []struct {
	Ctx           context.Context
	PublisherName string
	Batch         int
} {
	var calls []struct {
		Ctx           context.Context
		PublisherName string
		Batch         int
	}
	mock.lockMessages.RLock()
	calls = mock.calls.Messages
	mock.lockMessages.RUnlock()
	return calls
}

// SaveLastPublished calls SaveLastPublishedFunc.
func (mock *SourceMock) SaveLastPublished(ctx context.Context, publisherName string, msg *store.Message) error {
	callInfo := struct {
		Ctx           context.Context
		PublisherName string
		Msg           *store.Message
	}{
		Ctx:           ctx,
		PublisherName: publisherName,
		Msg:           msg,
	}
	mock.lockSaveLastPublished.Lock()
	mock.calls.SaveLastPublished = append(mock.calls.SaveLastPublished, callInfo)
	mock.lockSaveLastPublished.Unlock()
	if mock.SaveLastPublishedFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SaveLastPublishedFunc(ctx, publisherName, msg)
}

// SaveLastPublishedCalls gets all the calls that were made to SaveLastPublished.
// Check the length with:
//     len(mockedSource.SaveLastPublishedCalls())
func (mock *SourceMock) SaveLastPublishedCalls() []struct {
	Ctx           context.Context
	PublisherName string
	Msg           *store.Message
} {
	var calls []struct {
		Ctx           context.Context
		PublisherName string
		Msg           *store.Message
	}
	mock.lockSaveLastPublished.RLock()
	calls = mock.calls.SaveLastPublished
	mock.lockSaveLastPublished.RUnlock()
	return calls
}

// Ensure, that QueueMock does implement Queue.
// If this is not the case, regenerate this file with moq.
var _ Queue = &QueueMock{}

// QueueMock is a mock implementation of Queue.
//
// 	func TestSomethingThatUsesQueue(t *testing.T) {
//
// 		// make and configure a mocked Queue
// 		mockedQueue := &QueueMock{
// 			PublishFunc: func(ctx context.Context, msg *store.Message) error {
// 				panic("mock out the Publish method")
// 			},
// 		}
//
// 		// use mockedQueue in code that requires Queue
// 		// and then make assertions.
//
// 	}
type QueueMock struct {
	// PublishFunc mocks the Publish method.
	PublishFunc func(ctx context.Context, msg *store.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// Publish holds details about calls to the Publish method.
		Publish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg *store.Message
		}
	}
	lockPublish sync.RWMutex
}

// Publish calls PublishFunc.
func (mock *QueueMock) Publish(ctx context.Context, msg *store.Message) error {
	callInfo := struct {
		Ctx context.Context
		Msg *store.Message
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockPublish.Lock()
	mock.calls.Publish = append(mock.calls.Publish, callInfo)
	mock.lockPublish.Unlock()
	if mock.PublishFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PublishFunc(ctx, msg)
}

// PublishCalls gets all the calls that were made to Publish.
// Check the length with:
//     len(mockedQueue.PublishCalls())
func (mock *QueueMock) PublishCalls() []struct {
	Ctx context.Context
	Msg *store.Message
} {
	var calls []struct {
		Ctx context.Context
		Msg *store.Message
	}
	mock.lockPublish.RLock()
	calls = mock.calls.Publish
	mock.lockPublish.RUnlock()
	return calls
}

// Ensure, that ReporterMock does implement Reporter.
// If this is not the case, regenerate this file with moq.
var _ Reporter = &ReporterMock{}

// ReporterMock is a mock implementation of Reporter.
//
// 	func TestSomethingThatUsesReporter(t *testing.T) {
//
// 		// make and configure a mocked Reporter
// 		mockedReporter := &ReporterMock{
// 			ReportFunc: func(ctx context.Context, r *Report)  {
// 				panic("mock out the Report method")
// 			},
// 		}
//
// 		// use mockedReporter in code that requires Reporter
// 		// and then make assertions.
//
// 	}
type ReporterMock struct {
	// ReportFunc mocks the Report method.
	ReportFunc func(ctx context.Context, r *Report)

	// calls tracks calls to the methods.
	calls struct {
		// Report holds details about calls to the Report method.
		Report []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// R is the r argument value.
			R *Report
		}
	}
	lockReport sync.RWMutex
}

// Report calls ReportFunc.
func (mock *ReporterMock) Report(ctx context.Context, r *Report) {
	callInfo := struct {
		Ctx context.Context
		R   *Report
	}{
		Ctx: ctx,
		R:   r,
	}
	mock.lockReport.Lock()
	mock.calls.Report = append(mock.calls.Report, callInfo)
	mock.lockReport.Unlock()
	if mock.ReportFunc == nil {
		return
	}
	mock.ReportFunc(ctx, r)
}

// ReportCalls gets all the calls that were made to Report.
// Check the length with:
//     len(mockedReporter.ReportCalls())
func (mock *ReporterMock) ReportCalls() []struct {
	Ctx context.Context
	R   *Report
} {
	var calls []struct {
		Ctx context.Context
		R   *Report
	}
	mock.lockReport.RLock()
	calls = mock.calls.Report
	mock.lockReport.RUnlock()
	return calls
}
