// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package publish

import (
	"context"
	"github.com/xabi93/messenger/store"
	"sync"
)

// Ensure, that SourceMock does implement Source.
// If this is not the case, regenerate this file with moq.
var _ Source = &SourceMock{}

// SourceMock is a mock implementation of Source.
//
// 	func TestSomethingThatUsesSource(t *testing.T) {
//
// 		// make and configure a mocked Source
// 		mockedSource := &SourceMock{
// 			MessagesFunc: func(ctx context.Context, batch int64) ([]store.Message, error) {
// 				panic("mock out the Messages method")
// 			},
// 			PublishedFunc: func(ctx context.Context, msg ...store.Message) error {
// 				panic("mock out the Published method")
// 			},
// 		}
//
// 		// use mockedSource in code that requires Source
// 		// and then make assertions.
//
// 	}
type SourceMock struct {
	// MessagesFunc mocks the Messages method.
	MessagesFunc func(ctx context.Context, batch int64) ([]store.Message, error)

	// PublishedFunc mocks the Published method.
	PublishedFunc func(ctx context.Context, msg ...store.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// Messages holds details about calls to the Messages method.
		Messages []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Batch is the batch argument value.
			Batch int64
		}
		// Published holds details about calls to the Published method.
		Published []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg []store.Message
		}
	}
	lockMessages  sync.RWMutex
	lockPublished sync.RWMutex
}

// Messages calls MessagesFunc.
func (mock *SourceMock) Messages(ctx context.Context, batch int64) ([]store.Message, error) {
	callInfo := struct {
		Ctx   context.Context
		Batch int64
	}{
		Ctx:   ctx,
		Batch: batch,
	}
	mock.lockMessages.Lock()
	mock.calls.Messages = append(mock.calls.Messages, callInfo)
	mock.lockMessages.Unlock()
	if mock.MessagesFunc == nil {
		var (
			messagesOut []store.Message
			errOut      error
		)
		return messagesOut, errOut
	}
	return mock.MessagesFunc(ctx, batch)
}

// MessagesCalls gets all the calls that were made to Messages.
// Check the length with:
//     len(mockedSource.MessagesCalls())
func (mock *SourceMock) MessagesCalls() []struct {
	Ctx   context.Context
	Batch int64
} {
	var calls []struct {
		Ctx   context.Context
		Batch int64
	}
	mock.lockMessages.RLock()
	calls = mock.calls.Messages
	mock.lockMessages.RUnlock()
	return calls
}

// Published calls PublishedFunc.
func (mock *SourceMock) Published(ctx context.Context, msg ...store.Message) error {
	callInfo := struct {
		Ctx context.Context
		Msg []store.Message
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockPublished.Lock()
	mock.calls.Published = append(mock.calls.Published, callInfo)
	mock.lockPublished.Unlock()
	if mock.PublishedFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PublishedFunc(ctx, msg...)
}

// PublishedCalls gets all the calls that were made to Published.
// Check the length with:
//     len(mockedSource.PublishedCalls())
func (mock *SourceMock) PublishedCalls() []struct {
	Ctx context.Context
	Msg []store.Message
} {
	var calls []struct {
		Ctx context.Context
		Msg []store.Message
	}
	mock.lockPublished.RLock()
	calls = mock.calls.Published
	mock.lockPublished.RUnlock()
	return calls
}

// Ensure, that QueueMock does implement Queue.
// If this is not the case, regenerate this file with moq.
var _ Queue = &QueueMock{}

// QueueMock is a mock implementation of Queue.
//
// 	func TestSomethingThatUsesQueue(t *testing.T) {
//
// 		// make and configure a mocked Queue
// 		mockedQueue := &QueueMock{
// 			PublishFunc: func(ctx context.Context, msg store.Message) error {
// 				panic("mock out the Publish method")
// 			},
// 		}
//
// 		// use mockedQueue in code that requires Queue
// 		// and then make assertions.
//
// 	}
type QueueMock struct {
	// PublishFunc mocks the Publish method.
	PublishFunc func(ctx context.Context, msg store.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// Publish holds details about calls to the Publish method.
		Publish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg store.Message
		}
	}
	lockPublish sync.RWMutex
}

// Publish calls PublishFunc.
func (mock *QueueMock) Publish(ctx context.Context, msg store.Message) error {
	callInfo := struct {
		Ctx context.Context
		Msg store.Message
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockPublish.Lock()
	mock.calls.Publish = append(mock.calls.Publish, callInfo)
	mock.lockPublish.Unlock()
	if mock.PublishFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PublishFunc(ctx, msg)
}

// PublishCalls gets all the calls that were made to Publish.
// Check the length with:
//     len(mockedQueue.PublishCalls())
func (mock *QueueMock) PublishCalls() []struct {
	Ctx context.Context
	Msg store.Message
} {
	var calls []struct {
		Ctx context.Context
		Msg store.Message
	}
	mock.lockPublish.RLock()
	calls = mock.calls.Publish
	mock.lockPublish.RUnlock()
	return calls
}

// Ensure, that ReporterMock does implement Reporter.
// If this is not the case, regenerate this file with moq.
var _ Reporter = &ReporterMock{}

// ReporterMock is a mock implementation of Reporter.
//
// 	func TestSomethingThatUsesReporter(t *testing.T) {
//
// 		// make and configure a mocked Reporter
// 		mockedReporter := &ReporterMock{
// 			ErrorFunc: func(err error)  {
// 				panic("mock out the Error method")
// 			},
// 			FinishFunc: func()  {
// 				panic("mock out the Finish method")
// 			},
// 			InitFunc: func()  {
// 				panic("mock out the Init method")
// 			},
// 			TotalMessagesFunc: func(total int)  {
// 				panic("mock out the TotalMessages method")
// 			},
// 		}
//
// 		// use mockedReporter in code that requires Reporter
// 		// and then make assertions.
//
// 	}
type ReporterMock struct {
	// ErrorFunc mocks the Error method.
	ErrorFunc func(err error)

	// FinishFunc mocks the Finish method.
	FinishFunc func()

	// InitFunc mocks the Init method.
	InitFunc func()

	// TotalMessagesFunc mocks the TotalMessages method.
	TotalMessagesFunc func(total int)

	// calls tracks calls to the methods.
	calls struct {
		// Error holds details about calls to the Error method.
		Error []struct {
			// Err is the err argument value.
			Err error
		}
		// Finish holds details about calls to the Finish method.
		Finish []struct {
		}
		// Init holds details about calls to the Init method.
		Init []struct {
		}
		// TotalMessages holds details about calls to the TotalMessages method.
		TotalMessages []struct {
			// Total is the total argument value.
			Total int
		}
	}
	lockError         sync.RWMutex
	lockFinish        sync.RWMutex
	lockInit          sync.RWMutex
	lockTotalMessages sync.RWMutex
}

// Error calls ErrorFunc.
func (mock *ReporterMock) Error(err error) {
	callInfo := struct {
		Err error
	}{
		Err: err,
	}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	if mock.ErrorFunc == nil {
		return
	}
	mock.ErrorFunc(err)
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//     len(mockedReporter.ErrorCalls())
func (mock *ReporterMock) ErrorCalls() []struct {
	Err error
} {
	var calls []struct {
		Err error
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// Finish calls FinishFunc.
func (mock *ReporterMock) Finish() {
	callInfo := struct {
	}{}
	mock.lockFinish.Lock()
	mock.calls.Finish = append(mock.calls.Finish, callInfo)
	mock.lockFinish.Unlock()
	if mock.FinishFunc == nil {
		return
	}
	mock.FinishFunc()
}

// FinishCalls gets all the calls that were made to Finish.
// Check the length with:
//     len(mockedReporter.FinishCalls())
func (mock *ReporterMock) FinishCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFinish.RLock()
	calls = mock.calls.Finish
	mock.lockFinish.RUnlock()
	return calls
}

// Init calls InitFunc.
func (mock *ReporterMock) Init() {
	callInfo := struct {
	}{}
	mock.lockInit.Lock()
	mock.calls.Init = append(mock.calls.Init, callInfo)
	mock.lockInit.Unlock()
	if mock.InitFunc == nil {
		return
	}
	mock.InitFunc()
}

// InitCalls gets all the calls that were made to Init.
// Check the length with:
//     len(mockedReporter.InitCalls())
func (mock *ReporterMock) InitCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockInit.RLock()
	calls = mock.calls.Init
	mock.lockInit.RUnlock()
	return calls
}

// TotalMessages calls TotalMessagesFunc.
func (mock *ReporterMock) TotalMessages(total int) {
	callInfo := struct {
		Total int
	}{
		Total: total,
	}
	mock.lockTotalMessages.Lock()
	mock.calls.TotalMessages = append(mock.calls.TotalMessages, callInfo)
	mock.lockTotalMessages.Unlock()
	if mock.TotalMessagesFunc == nil {
		return
	}
	mock.TotalMessagesFunc(total)
}

// TotalMessagesCalls gets all the calls that were made to TotalMessages.
// Check the length with:
//     len(mockedReporter.TotalMessagesCalls())
func (mock *ReporterMock) TotalMessagesCalls() []struct {
	Total int
} {
	var calls []struct {
		Total int
	}
	mock.lockTotalMessages.RLock()
	calls = mock.calls.TotalMessages
	mock.lockTotalMessages.RUnlock()
	return calls
}
